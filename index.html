<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Recognition</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <style>
      body {
        font-family: 'Segoe UI', Arial, sans-serif;
        background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 10px;
      }
      .container {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        padding: 15px;
        max-width: 400px;
        width: 100%;
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
      }
      .logo {
        width: 100px;
        height: 33px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
      }
      .logo:hover {
        transform: scale(1.05);
      }
      a {
        text-decoration: none;
      }
      h1 {
        font-size: 24px;
        color: #333;
        text-align: center;
        background: linear-gradient(45deg, #007BFF, #00C4B4);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 15px;
      }
      .section {
        margin: 10px 0;
        padding: 10px;
        border-radius: 8px;
        background: #f9f9f9;
      }
      button {
        padding: 12px 20px;
        font-size: 15px;
        border: none;
        border-radius: 6px;
        background: #007BFF;
        color: white;
        cursor: pointer;
        touch-action: manipulation;
        transition: transform 0.2s, box-shadow 0.2s;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }
      button:active {
        transform: translateY(0);
        box-shadow: none;
      }
      button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }
      input {
        padding: 12px;
        font-size: 15px;
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 6px;
        margin-bottom: 10px;
      }
      #connectBtn {
        background: #28A745;
      }
      #bluetoothWarning {
        display: none;
        padding: 10px;
        border-radius: 6px;
        background: #ffe6e6;
        color: #DC3545;
        font-size: 14px;
        text-align: center;
        margin-bottom: 10px;
      }
      #webcam-container {
        display: flex;
        justify-content: center;
        margin: 10px 0;
      }
      #webcam-container canvas {
        width: 192px;
        height: 192px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }
      #predictions {
        margin: 10px 0;
        text-align: left;
      }
      #status {
        padding: 10px;
        border-radius: 6px;
        font-size: 14px;
        text-align: center;
        transition: opacity 0.5s;
      }
      #status.success {
        background: #e6ffed;
        color: #28A745;
      }
      #status.error {
        background: #ffe6e6;
        color: #DC3545;
      }
      .prediction-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        padding: 5px;
        border-radius: 4px;
      }
      .prediction-item.highest {
        background: #e6f3ff;
        font-weight: bold;
      }
      .prediction-label {
        width: 100px;
        font-size: 13px;
      }
      .prediction-value {
        width: 60px;
        font-size: 13px;
        text-align: right;
      }
      .prediction-bar {
        width: 100px;
        margin-left: 8px;
      }
      progress {
        width: 100%;
        height: 10px;
        border-radius: 5px;
        background: #e0e0e0;
        border: none;
      }
      progress::-webkit-progress-bar {
        background: #e0e0e0;
        border-radius: 5px;
      }
      progress::-webkit-progress-value {
        background: linear-gradient(90deg, #ff6b6b, #28A745);
        border-radius: 5px;
        transition: width 0.3s ease;
      }
      progress::-moz-progress-bar {
        background: linear-gradient(90deg, #ff6b6b, #28A745);
        border-radius: 5px;
        transition: width 0.3s ease;
      }
      .spinner {
        display: none;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #007BFF;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        animation: spin 1s linear infinite;
        margin: 8px auto;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      @media (max-width: 500px) {
        .container {
          max-width: 95%;
        }
        .header {
          flex-direction: column;
          align-items: flex-start;
        }
        .logo {
          width: 80px;
          height: 27px;
        }
        #connectBtn {
          margin-top: 8px;
        }
        h1 {
          font-size: 20px;
        }
        button, input {
          font-size: 14px;
          padding: 10px;
        }
        .prediction-label, .prediction-value {
          font-size: 12px;
        }
        .prediction-bar {
          width: 80px;
        }
        #webcam-container canvas {
          width: 180px;
          height: 180px;
        }
      }
    </style>
</head>
<body>
    <div class="header">
      <a href="https://www.pi-innovation.com.hk/?gad_source=1&gad_campaignid=21494171243&gbraid=0AAAAA-BsQmygjW-N2d2LI6KeFnseTQiJV&gclid=Cj0KCQjwovPGBhDxARIsAFhgkwT4ORGyhypiLhn92R2vyb9LAPLZtahD-tHDPa9OaBrmUAE_pM-DwwcaAl4kEALw_wcB" target="_blank">
        <img src="https://hkese.net/sites/default/files/organization_logos/pi-innovation-final-01_1_20230514.png" alt="PI Innovation Logo" class="logo">
      </a>
      <button id="connectBtn" title="連接到 micro:bit">CONNECT</button>
    </div>
    <div id="bluetoothWarning"></div>
    <div class="container">
      <h1>Image Recognition</h1>

      <div class="section">
        <h2>Model URL</h2>
        <input type="text" id="modelInput" placeholder="Enter Teachable Machine model URL">
        <button id="loadModelBtn" title="載入 Teachable Machine 模型">Load Model</button>
        <div id="status"></div>
        <div id="modelSpinner" class="spinner"></div>
      </div>

      <div class="section">
        <h2>Webcam Preview</h2>
        <div id="webcam-container"></div>
        <button id="webcamBtn" title="開啟 webcam 進行圖像辨識" disabled>Open Webcam</button>
        <div id="predictions"></div>
        <div id="webcamSpinner" class="spinner"></div>
      </div>
    </div>

    <script>
      const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
      const UART_TX_CHARACTERISTIC_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
      const UART_RX_CHARACTERISTIC_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";

      let uBitDevice;
      let rxCharacteristic;
      let model, webcam, labelContainer, maxPredictions, lastSentClass = null;
      let isPredicting = false;

      // Check Bluetooth support
      const connectBtn = document.getElementById("connectBtn");
      const bluetoothWarning = document.getElementById("bluetoothWarning");
      function checkBluetoothSupport() {
        if (!navigator.bluetooth) {
          connectBtn.style.display = "none";
          bluetoothWarning.style.display = "block";
          bluetoothWarning.innerText = "⚠️ 此瀏覽器不支援藍牙連線，請使用 Chrome 瀏覽器（Android 6.0+ 或桌面）。";
        } else if (window.location.protocol !== "https:" && window.location.hostname !== "localhost") {
          connectBtn.style.display = "none";
          bluetoothWarning.style.display = "block";
          bluetoothWarning.innerText = "⚠️ 藍牙功能需在 HTTPS 或 localhost 環境運行，請檢查網站協議。";
        } else {
          navigator.bluetooth.getAvailability().then(available => {
            if (!available) {
              connectBtn.style.display = "none";
              bluetoothWarning.style.display = "block";
              bluetoothWarning.innerText = "⚠️ 請開啟設備藍牙並確保 Chrome 已授予藍牙權限。";
            } else {
              connectBtn.style.display = "block";
              bluetoothWarning.style.display = "none";
            }
          }).catch(() => {
            connectBtn.style.display = "block";
            bluetoothWarning.style.display = "none";
          });
        }
      }
      checkBluetoothSupport();

      // Bind button events
      connectBtn.addEventListener("click", connectButtonPressed);
      connectBtn.addEventListener("touchstart", connectButtonPressed);
      document.getElementById("loadModelBtn").addEventListener("click", loadModel);
      document.getElementById("loadModelBtn").addEventListener("touchstart", loadModel);
      document.getElementById("webcamBtn").addEventListener("click", setupWebcam);
      document.getElementById("webcamBtn").addEventListener("touchstart", setupWebcam);
      document.getElementById("modelInput").addEventListener("keypress", (e) => {
        if (e.key === "Enter") loadModel();
      });

      async function connectButtonPressed() {
        try {
          console.log("Requesting Bluetooth Device...");
          uBitDevice = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "BBC micro:bit" }],
            optionalServices: [UART_SERVICE_UUID],
          });

          uBitDevice.addEventListener("gattserverdisconnected", onDisconnected);

          console.log("Connecting to GATT Server...");
          const server = await uBitDevice.gatt.connect();

          console.log("Getting Service...");
          const service = await server.getPrimaryService(UART_SERVICE_UUID);

          console.log("Getting Characteristics...");
          const txCharacteristic = await service.getCharacteristic(
            UART_TX_CHARACTERISTIC_UUID
          );
          txCharacteristic.startNotifications();
          txCharacteristic.addEventListener(
            "characteristicvaluechanged",
            onTxCharacteristicValueChanged
          );

          rxCharacteristic = await service.getCharacteristic(
            UART_RX_CHARACTERISTIC_UUID
          );

          console.log("Connected to micro:bit");
          updateStatus("藍牙已連接到 micro:bit", false);
        } catch (error) {
          console.error("Connection failed:", error);
          updateStatus("藍牙連接失敗: " + error.message, true);
        }
      }

      async function sendData(data) {
        if (!rxCharacteristic) {
          console.warn("Device not connected");
          updateStatus("設備未連接，無法發送數據", true);
          return;
        }
        try {
          let encoder = new TextEncoder();
          queueGattOperation(() =>
            rxCharacteristic
              .writeValue(encoder.encode(data + "\n"))
              .then(() => {
                console.log("Sent:", data);
                updateStatus(`已發送數據: ${data}`, false);
              })
              .catch((error) => {
                console.error("Send failed:", error);
                updateStatus("發送失敗: " + error.message, true);
              })
          );
        } catch (error) {
          console.error("Send error:", error);
          updateStatus("發送錯誤: " + error.message, true);
        }
      }

      let queue = Promise.resolve();
      function queueGattOperation(operation) {
        queue = queue.then(operation, operation);
        return queue;
      }

      function onTxCharacteristicValueChanged(event) {
        let receivedData = [];
        for (let i = 0; i < event.target.value.byteLength; i++) {
          receivedData[i] = event.target.value.getUint8(i);
        }
        const receivedString = String.fromCharCode.apply(null, receivedData);
        console.log("Received:", receivedString);
        updateStatus(`收到數據: ${receivedString}`, false);
      }

      function onDisconnected(event) {
        console.log("micro:bit is disconnected.");
        updateStatus("micro:bit 已斷開連接", true);
      }

      function updateStatus(message, isError) {
        const statusDiv = document.getElementById("status");
        statusDiv.innerText = (isError ? "❌ " : "✅ ") + message;
        statusDiv.className = isError ? "error" : "success";
        if (!isError) {
          setTimeout(() => {
            statusDiv.style.opacity = 0;
            setTimeout(() => {
              statusDiv.innerText = "";
              statusDiv.style.opacity = 1;
            }, 500);
          }, 3000);
        }
      }

      async function loadModel() {
        let modelUrl = document.getElementById('modelInput').value.trim();
        if (!modelUrl) {
          updateStatus("請輸入模型 URL", true);
          return;
        }
        if (!modelUrl.endsWith('model.json')) {
          modelUrl = modelUrl.replace(/\/$/, '') + '/model.json';
        }
        const metadataUrl = modelUrl.replace('model.json', 'metadata.json');
        try {
          document.getElementById("loadModelBtn").disabled = true;
          document.getElementById("modelSpinner").style.display = "block";
          model = await tmImage.load(modelUrl, metadataUrl);
          maxPredictions = model.getTotalClasses();
          console.log('Model loaded, classes:', maxPredictions);
          updateStatus("模型已成功載入", false);
          document.getElementById("webcamBtn").disabled = false;
        } catch (error) {
          console.error('Error loading model:', error);
          updateStatus("模型載入失敗: " + error.message, true);
        } finally {
          document.getElementById("loadModelBtn").disabled = false;
          document.getElementById("modelSpinner").style.display = "none";
        }
      }

      async function setupWebcam() {
        try {
          // Check HTTPS
          if (window.location.protocol !== "https:" && window.location.hostname !== "localhost") {
            updateStatus("Webcam 功能需在 HTTPS 或 localhost 環境運行", true);
            return;
          }

          // Check camera availability
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            updateStatus("此瀏覽器不支援攝影機，請檢查瀏覽器或設備設置", true);
            return;
          }

          // Log available devices
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          console.log("Available video devices:", videoDevices);
          if (videoDevices.length === 0) {
            updateStatus("未找到可用攝影機，請檢查設備", true);
            return;
          }

          document.getElementById("webcamBtn").disabled = true;
          document.getElementById("webcamSpinner").style.display = "block";

          // Initialize webcam
          webcam = new tmImage.Webcam(192, 192, true); // Reduced resolution
          const videoElement = webcam.webcam;
          videoElement.setAttribute("playsinline", true); // Required for Safari

          // Try to access camera (prefer rear, fallback to any)
          let stream;
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: { 
                facingMode: "environment", // Prefer rear camera
                width: { ideal: 192 },
                height: { ideal: 192 }
              }
            });
          } catch (rearError) {
            console.warn("Rear camera failed, trying any camera:", rearError);
            stream = await navigator.mediaDevices.getUserMedia({
              video: { 
                width: { ideal: 192 },
                height: { ideal: 192 }
              }
            });
          }
          webcam.webcam.srcObject = stream;
          await webcam.play();

          document.getElementById("webcam-container").appendChild(webcam.canvas);
          labelContainer = document.getElementById("predictions");
          for (let i = 0; i < maxPredictions; i++) {
            const item = document.createElement("div");
            item.className = "prediction-item";
            item.innerHTML = `
              <span class="prediction-label"></span>
              <span class="prediction-value"></span>
              <progress class="prediction-bar" value="0" max="100"></progress>
            `;
            labelContainer.appendChild(item);
          }
          updateStatus("Webcam 已成功啟動", false);
          if (model && !isPredicting) {
            window.requestAnimationFrame(loop);
            isPredicting = true;
          }
        } catch (error) {
          console.error('Error accessing webcam:', error);
          let errorMessage = "Webcam 啟動失敗: " + error.message;
          if (error.name === "NotAllowedError") {
            errorMessage = "Webcam 啟動失敗: 請允許攝影機權限";
          } else if (error.name === "NotFoundError") {
            errorMessage = "Webcam 啟動失敗: 未找到可用攝影機";
          } else if (error.name === "NotReadableError") {
            errorMessage = "Webcam 啟動失敗: 攝影機被其他應用程式佔用";
          }
          updateStatus(errorMessage, true);
        } finally {
          document.getElementById("webcamBtn").disabled = false;
          document.getElementById("webcamSpinner").style.display = "none";
        }
      }

      async function loop() {
        if (webcam && model) {
          webcam.update(); // Update the webcam frame
          await predict();
        } else {
          updateStatus("等待 Webcam 或模型初始化...", true);
        }
        window.requestAnimationFrame(loop);
      }

      async function predict() {
        const prediction = await model.predict(webcam.canvas);
        let maxProb = 0;
        let maxIndex = 0;
        for (let i = 0; i < maxPredictions; i++) {
          const prob = (prediction[i].probability * 100).toFixed(2);
          const item = labelContainer.childNodes[i];
          item.querySelector(".prediction-label").innerText = prediction[i].className;
          item.querySelector(".prediction-value").innerText = `${prob}%`;
          item.querySelector(".prediction-bar").value = prob;
          item.classList.toggle("highest", prob > maxProb);
          if (prob > maxProb) {
            maxProb = prob;
            maxIndex = i;
          }
          if (prediction[i].probability >= 0.995 && prediction[i].className !== lastSentClass) {
            sendData(prediction[i].className);
            lastSentClass = prediction[i].className;
          }
        }
      }
    </script>
</body>
</html>
<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Micro:bit Web App</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.4.0/dist/speech-commands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
    <style>
      body {
        font-family: 'Segoe UI', Arial, sans-serif;
        background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 10px;
      }
      .container {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        padding: 15px;
        max-width: 400px;
        width: 100%;
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
        flex-wrap: wrap;
        gap: 10px;
      }
      .logo {
        width: 100px;
        height: 33px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
      }
      .logo:hover {
        transform: scale(1.05);
      }
      a {
        text-decoration: none;
      }
      h1 {
        font-size: 24px;
        color: #333;
        text-align: center;
        background: linear-gradient(45deg, #007BFF, #00C4B4);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }
      .section {
        margin: 10px 0;
        padding: 10px;
        border-radius: 8px;
        background: #f9f9f9;
      }
      button {
        padding: 12px 20px;
        font-size: 15px;
        border: none;
        border-radius: 6px;
        background: #007BFF;
        color: white;
        cursor: pointer;
        touch-action: manipulation;
        transition: transform 0.2s, box-shadow 0.2s;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }
      button:active {
        transform: translateY(0);
        box-shadow: none;
      }
      button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }
      select {
        padding: 12px;
        font-size: 15px;
        width: 150px;
        border: 1px solid #ccc;
        border-radius: 6px;
        margin: 0 auto 10px;
        display: block;
      }
      input[type="text"] {
        padding: 12px;
        font-size: 15px;
        width: 250px;
        border: 1px solid #ccc;
        border-radius: 6px;
        margin: 0 auto 10px;
        display: block;
      }
      input[type="number"] {
        padding: 12px;
        font-size: 15px;
        width: 80px;
        border: 1px solid #ccc;
        border-radius: 6px;
        margin: 0 auto 10px;
        display: block;
      }
      #connectBtn {
        background: #28A745;
      }
      #connectUSBBtn {
        background: #6F42C1;
      }
      #switchCameraBtn {
        background: #17A2B8;
        margin-top: 10px;
      }
      #startGameBtn {
        background: #FF851B;
      }
      #resetGameBtn {
        background: #DC3545;
      }
      #bluetoothWarning {
        display: none;
        padding: 10px;
        border-radius: 6px;
        background: #ffe6e6;
        color: #DC3545;
        font-size: 14px;
        text-align: center;
        margin-bottom: 10px;
      }
      #webcam-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 10px 0;
        overflow: hidden;
      }
      #webcam-container video {
        display: none;
      }
      #webcam-container canvas {
        width: 192px;
        height: 192px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        object-fit: contain;
      }
      #predictions {
        margin: 10px 0;
        text-align: left;
      }
      #status {
        padding: 10px;
        border-radius: 6px;
        font-size: 14px;
        text-align: center;
        transition: opacity 0.5s;
      }
      #status.success {
        background: #e6ffed;
        color: #28A745;
      }
      #status.error {
        background: #ffe6e6;
        color: #DC3545;
      }
      .prediction-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        padding: 5px;
        border-radius: 4px;
      }
      .prediction-item.highest {
        background: #e6f3ff;
        font-weight: bold;
      }
      .prediction-label {
        width: 150px;
        font-size: 13px;
      }
      .prediction-value {
        width: 60px;
        font-size: 13px;
        text-align: right;
      }
      .prediction-bar {
        width: 100px;
        margin-left: 8px;
      }
      progress {
        width: 100%;
        height: 10px;
        border-radius: 5px;
        background: #e0e0e0;
        border: none;
      }
      progress::-webkit-progress-bar {
        background: #e0e0e0;
        border-radius: 5px;
      }
      progress::-webkit-progress-value {
        background: linear-gradient(90deg, #ff6b6b, #28A745);
        border-radius: 5px;
        transition: width 0.3s ease;
      }
      progress::-moz-progress-bar {
        background: linear-gradient(90deg, #ff6b6b, #28A745);
        border-radius: 5px;
        transition: width 0.3s ease;
      }
      .spinner {
        display: none;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #007BFF;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        animation: spin 1s linear infinite;
        margin: 8px auto;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      #gameStatus {
        text-align: center;
        font-size: 16px;
        margin: 10px 0;
      }
      #targetClass {
        font-weight: bold;
        color: #007BFF;
      }
      #timer {
        font-weight: bold;
        color: #28A745;
      }
      #matchCount {
        font-weight: bold;
        color: #FF851B;
      }
      #gameResult {
        display: none;
        text-align: center;
        font-size: 16px;
        margin: 10px 0;
        color: #28A745;
      }
      .hidden {
        display: none;
      }
      @media (max-width: 500px) {
        .container {
          max-width: 95%;
        }
        .header {
          flex-direction: column;
          align-items: flex-start;
        }
        .logo {
          width: 80px;
          height: 27px;
        }
        #connectBtn, #connectUSBBtn {
          margin-top: 8px;
        }
        h1 {
          font-size: 20px;
        }
        button, input, select {
          font-size: 14px;
          padding: 10px;
        }
        .prediction-label, .prediction-value {
          font-size: 12px;
        }
        .prediction-bar {
          width: 80px;
        }
        #webcam-container canvas {
          width: 180px;
          height: 180px;
          max-width: 180px;
          max-height: 180px;
        }
        #switchCameraBtn {
          display: block;
        }
      }
      @media (min-width: 501px) {
        #switchCameraBtn {
          display: none;
        }
      }
    </style>
</head>
<body>
    <div class="header">
      <a href="https://www.pi-innovation.com.hk/?gad_source=1&gad_campaignid=21494171243&gbraid=0AAAAA-BsQmygjW-N2d2LI6KeFnseTQiJV&gclid=Cj0KCQjwovPGBhDxARIsAFhgkwT4ORGyhypiLhn92R2vyb9LAPLZtahD-tHDPa9OaBrmUAE_pM-DwwcaAl4kEALw_wcB" target="_blank">
        <img src="https://hkese.net/sites/default/files/organization_logos/pi-innovation-final-01_1_20230514.png" alt="PI Innovation Logo" class="logo">
      </a>
      <div>
        <button id="connectBtn" title="連接到 micro:bit（藍牙）">Connect Bluetooth</button>
        <button id="connectUSBBtn" title="連接到 micro:bit（USB）">Connect USB</button>
      </div>
    </div>
    <div id="bluetoothWarning"></div>
    <div class="container">
      <h1><span id="projectTitle">Image Project</span>
        <select id="projectType" title="選擇專案類型">
          <option value="image">Image Project</option>
          <option value="audio">Audio Project</option>
          <option value="pose">Pose Project</option>
        </select>
      </h1>

      <div class="section" id="model-section">
        <h2>Model URL</h2>
        <input type="text" id="modelInput" placeholder="Enter Teachable Machine model URL">
        <button id="loadModelBtn" title="載入 Teachable Machine 模型">Load Model</button>
        <div id="status"></div>
        <div id="modelSpinner" class="spinner"></div>
      </div>

      <div class="section" id="webcam-section">
        <h2>Webcam Preview</h2>
        <div id="webcam-container">
          <button id="switchCameraBtn" title="切換前後攝影機" disabled>Switch to Front Camera</button>
        </div>
        <button id="webcamBtn" title="開啟 webcam 進行辨識" disabled>Open Webcam</button>
        <div id="predictions"></div>
        <div id="webcamSpinner" class="spinner"></div>
      </div>

      <div class="section hidden" id="gameSection">
        <h2>Matching Game</h2>
        <label for="matchGoal">Number of Matches (5-20):</label>
        <input type="number" id="matchGoal" min="5" max="20" value="10">
        <button id="startGameBtn" title="開始遊戲" disabled>Start Game</button>
        <button id="resetGameBtn" title="重置遊戲" disabled>Reset Game</button>
        <div id="gameStatus">
          <p>Target: <span id="targetClass"></span></p>
          <p>Matches: <span id="matchCount">0</span>/<span id="currentMatchGoal">10</span></p>
          <p>Time: <span id="timer">0</span> seconds</p>
        </div>
        <div id="gameResult"></div>
      </div>
    </div>

    <script>
      const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
      const UART_TX_CHARACTERISTIC_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
      const UART_RX_CHARACTERISTIC_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";

      let uBitDevice;
      let rxCharacteristic;
      let serialPort;
      let model, labelContainer, maxPredictions, lastSentClass = null;
      let isPredicting = false;
      let videoElement = null;
      let canvasElement = null;
      let stream = null;
      let currentFacingMode = "environment";
      let projectType = "image";
      let webcam = null;
      let ctx = null;

      // Game variables
      let isGameMode = false;
      let classNames = [];
      let currentTarget = "";
      let lastTarget = "";
      let matchCount = 0;
      let matchGoal = 10;
      let gameStartTime = null;
      let gameTimerInterval = null;

      // Check Bluetooth and Serial support
      const connectBtn = document.getElementById("connectBtn");
      const connectUSBBtn = document.getElementById("connectUSBBtn");
      const bluetoothWarning = document.getElementById("bluetoothWarning");
      function checkConnectivitySupport() {
        if (!navigator.bluetooth && !navigator.serial) {
          connectBtn.style.display = "none";
          connectUSBBtn.style.display = "none";
          bluetoothWarning.style.display = "block";
          bluetoothWarning.innerText = "⚠️ 此瀏覽器不支援 USB 和藍牙連線，請使用 Chrome 瀏覽器（Android 6.0+ 或桌面）。";
        } else if (window.location.protocol !== "https:" && window.location.hostname !== "localhost") {
          connectBtn.style.display = "none";
          connectUSBBtn.style.display = "none";
          bluetoothWarning.style.display = "block";
          bluetoothWarning.innerText = "⚠️ USB 和藍牙功能需在 HTTPS 或 localhost 環境運行，請檢查網站協議。";
        } else {
          if (navigator.bluetooth) {
            navigator.bluetooth.getAvailability().then(available => {
              if (!available) {
                connectBtn.style.display = "none";
                bluetoothWarning.style.display = "block";
                bluetoothWarning.innerText = "⚠️ 請開啟設備藍牙並確保 Chrome 已授予藍牙權限。";
              } else {
                connectBtn.style.display = "block";
                bluetoothWarning.style.display = "none";
              }
            }).catch(() => {
              connectBtn.style.display = "block";
              bluetoothWarning.style.display = "none";
            });
          } else {
            connectBtn.style.display = "none";
          }
          if (navigator.serial) {
            connectUSBBtn.style.display = "block";
          } else {
            connectUSBBtn.style.display = "none";
            if (!navigator.bluetooth) {
              bluetoothWarning.style.display = "block";
              bluetoothWarning.innerText = "⚠️ 此瀏覽器不支援 USB 和藍牙連線，請使用 Chrome 瀏覽器。";
            }
          }
        }
      }
      checkConnectivitySupport();

      // Bind button events
      connectBtn.addEventListener("click", connectBluetooth);
      connectBtn.addEventListener("touchstart", connectBluetooth);
      connectUSBBtn.addEventListener("click", connectUSB);
      connectUSBBtn.addEventListener("touchstart", connectUSB);
      document.getElementById("loadModelBtn").addEventListener("click", loadModel);
      document.getElementById("loadModelBtn").addEventListener("touchstart", loadModel);
      document.getElementById("webcamBtn").addEventListener("click", setupWebcam);
      document.getElementById("webcamBtn").addEventListener("touchstart", setupWebcam);
      document.getElementById("modelInput").addEventListener("keypress", (e) => {
        if (e.key === "Enter") loadModel();
      });
      const switchCameraBtn = document.getElementById("switchCameraBtn");
      switchCameraBtn.addEventListener("click", switchCamera);
      switchCameraBtn.addEventListener("touchstart", switchCamera);
      document.getElementById("startGameBtn").addEventListener("click", startGame);
      document.getElementById("resetGameBtn").addEventListener("click", resetGame);
      document.getElementById("projectType").addEventListener("change", (e) => {
        projectType = e.target.value;
        resetProject();
        updateUI();
      });

      function updateUI() {
        const projectTitle = document.getElementById("projectTitle");
        projectTitle.innerText = projectType === "image" ? "Image Project" : projectType === "audio" ? "Audio Project" : "Pose Project";
        const webcamSection = document.getElementById("webcam-section");
        const gameSection = document.getElementById("gameSection");
        if (projectType === "audio") {
          webcamSection.classList.add("hidden");
          gameSection.classList.add("hidden");
          document.getElementById("webcamBtn").disabled = true;
        } else {
          webcamSection.classList.remove("hidden");
          document.getElementById("webcamBtn").disabled = model ? false : true;
          gameSection.classList.remove("hidden");
          document.getElementById("startGameBtn").disabled = model ? false : true;
        }
      }

      async function connectBluetooth() {
        try {
          console.log("Requesting Bluetooth Device...");
          uBitDevice = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "BBC micro:bit" }],
            optionalServices: [UART_SERVICE_UUID],
          });
          uBitDevice.addEventListener("gattserverdisconnected", onBluetoothDisconnected);
          console.log("Connecting to GATT Server...");
          const server = await uBitDevice.gatt.connect();
          console.log("Getting Service...");
          const service = await server.getPrimaryService(UART_SERVICE_UUID);
          console.log("Getting Characteristics...");
          const txCharacteristic = await service.getCharacteristic(UART_TX_CHARACTERISTIC_UUID);
          txCharacteristic.startNotifications();
          txCharacteristic.addEventListener("characteristicvaluechanged", onTxCharacteristicValueChanged);
          rxCharacteristic = await service.getCharacteristic(UART_RX_CHARACTERISTIC_UUID);
          console.log("Connected to micro:bit via Bluetooth");
          updateStatus("藍牙已連接到 micro:bit", false);
        } catch (error) {
          console.error("Bluetooth connection failed:", error);
          updateStatus("藍牙連接失敗: " + error.message, true);
        }
      }

      async function connectUSB() {
        try {
          console.log("Requesting Serial Port...");
          serialPort = await navigator.serial.requestPort({});
          await serialPort.open({ baudRate: 9600 });
          console.log("Connected to micro:bit via USB");
          updateStatus("USB 已連接到 micro:bit", false);
          serialPort.addEventListener("disconnect", () => {
            console.log("USB port disconnected");
            updateStatus("USB 已斷開連接", true);
            serialPort = null;
          });
        } catch (error) {
          console.error("USB connection failed:", error);
          let errorMessage = "USB 連接失敗: " + error.message;
          if (error.name === "NotFoundError") {
            errorMessage = "USB 連接失敗: 未找到可用序列埠，請確認 micro:bit 已連接";
          } else if (error.name === "SecurityError") {
            errorMessage = "USB 連接失敗: 請在 HTTPS 或 localhost 環境運行";
          }
          updateStatus(errorMessage, true);
        }
      }

      async function sendData(data) {
        if (projectType === "audio") return;
        try {
          if (serialPort) {
            const writer = serialPort.writable.getWriter();
            const encoder = new TextEncoder();
            await writer.write(encoder.encode(data + "\n"));
            writer.releaseLock();
            console.log("Sent via USB:", data);
            updateStatus(`已通過 USB 發送數據: ${data}`, false);
            return;
          }
          if (rxCharacteristic) {
            const encoder = new TextEncoder();
            await queueGattOperation(() =>
              rxCharacteristic.writeValue(encoder.encode(data + "\n")).then(() => {
                console.log("Sent via Bluetooth:", data);
                updateStatus(`已通過藍牙發送數據: ${data}`, false);
              })
            );
            return;
          }
          console.warn("No device connected");
          updateStatus("設備未連接，無法發送數據", true);
        } catch (error) {
          console.error("Send error:", error);
          updateStatus("發送錯誤: " + error.message, true);
        }
      }

      let queue = Promise.resolve();
      function queueGattOperation(operation) {
        queue = queue.then(operation, operation);
        return queue;
      }

      function onTxCharacteristicValueChanged(event) {
        let receivedData = [];
        for (let i = 0; i < event.target.value.byteLength; i++) {
          receivedData[i] = event.target.value.getUint8(i);
        }
        const receivedString = String.fromCharCode.apply(null, receivedData);
        console.log("Received via Bluetooth:", receivedString);
        updateStatus(`收到藍牙數據: ${receivedString}`, false);
      }

      function onBluetoothDisconnected(event) {
        console.log("micro:bit Bluetooth disconnected");
        updateStatus("藍牙已斷開連接", true);
        rxCharacteristic = null;
      }

      function updateStatus(message, isError) {
        const statusDiv = document.getElementById("status");
        statusDiv.innerText = (isError ? "❌ " : "✅ ") + message;
        statusDiv.className = isError ? "error" : "success";
        if (!isError) {
          setTimeout(() => {
            statusDiv.style.opacity = 0;
            setTimeout(() => {
              statusDiv.innerText = "";
              statusDiv.style.opacity = 1;
            }, 500);
          }, 3000);
        }
      }

      function resetProject() {
        if (isPredicting) {
          isPredicting = false;
          if (projectType === "audio" && model && model.stopListening) {
            model.stopListening();
          }
          if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
          }
          if (webcam && projectType === "pose") {
            webcam.stop();
            webcam = null;
          }
        }
        model = null;
        lastSentClass = null;
        classNames = [];
        document.getElementById("predictions").innerHTML = "";
        document.getElementById("webcam-container").innerHTML = '<button id="switchCameraBtn" title="切換前後攝影機" disabled>Switch to Front Camera</button>';
        document.getElementById("webcamBtn").disabled = true;
        document.getElementById("startGameBtn").disabled = true;
        resetGame();
      }

      async function loadModel() {
        let modelUrl = document.getElementById('modelInput').value.trim();
        if (!modelUrl) {
          updateStatus("請輸入模型 URL", true);
          return;
        }
        if (!modelUrl.endsWith('model.json')) {
          modelUrl = modelUrl.replace(/\/$/, '') + '/model.json';
        }
        const metadataUrl = modelUrl.replace('model.json', 'metadata.json');
        try {
          document.getElementById("loadModelBtn").disabled = true;
          document.getElementById("modelSpinner").style.display = "block";
          if (projectType === "image") {
            model = await tmImage.load(modelUrl, metadataUrl);
            maxPredictions = model.getTotalClasses();
            classNames = model.getClassLabels();
            console.log('Image model loaded, classes:', classNames);
            updateStatus("圖像模型已成功載入", false);
            document.getElementById("webcamBtn").disabled = false;
            document.getElementById("startGameBtn").disabled = false;
          } else if (projectType === "audio") {
            model = speechCommands.create("BROWSER_FFT", undefined, modelUrl, metadataUrl);
            await model.ensureModelLoaded();
            maxPredictions = model.wordLabels().length;
            classNames = model.wordLabels();
            console.log('Audio model loaded, classes:', classNames);
            updateStatus("音訊模型已成功載入", false);
            labelContainer = document.getElementById("predictions");
            labelContainer.innerHTML = "";
            for (let i = 0; i < maxPredictions; i++) {
              const item = document.createElement("div");
              item.className = "prediction-item";
              item.innerHTML = `<span class="prediction-label">${classNames[i]}</span><span class="prediction-value"></span>`;
              labelContainer.appendChild(item);
            }
            model.listen(result => {
              for (let i = 0; i < maxPredictions; i++) {
                const prob = (result.scores[i] * 100).toFixed(2);
                labelContainer.childNodes[i].querySelector(".prediction-value").innerText = `${prob}%`;
              }
            }, {
              includeSpectrogram: true,
              probabilityThreshold: 0.75,
              invokeCallbackOnNoiseAndUnknown: true,
              overlapFactor: 0.50
            });
            isPredicting = true;
          } else if (projectType === "pose") {
            model = await tmPose.load(modelUrl, metadataUrl);
            maxPredictions = model.getTotalClasses();
            classNames = model.getClassLabels();
            console.log('Pose model loaded, classes:', classNames);
            updateStatus("姿勢模型已成功載入", false);
            document.getElementById("webcamBtn").disabled = false;
            document.getElementById("startGameBtn").disabled = false;
          }
        } catch (error) {
          console.error('Error loading model:', error);
          updateStatus("模型載入失敗: " + error.message, true);
        } finally {
          document.getElementById("loadModelBtn").disabled = false;
          document.getElementById("modelSpinner").style.display = "none";
        }
      }

      async function startCamera(facingMode) {
        try {
          if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
          }
          let targetWidth = 192;
          let targetHeight = 192;
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: { 
                facingMode: facingMode,
                width: { ideal: 192 },
                height: { ideal: 192 }
              }
            });
          } catch (error) {
            console.warn(`Failed to access ${facingMode} camera, trying lower resolution:`, error);
            stream = await navigator.mediaDevices.getUserMedia({
              video: { 
                facingMode: facingMode,
                width: { ideal: 160 },
                height: { ideal: 160 }
              }
            });
            targetWidth = 160;
            targetHeight = 160;
          }
          videoElement.srcObject = stream;
          canvasElement.width = targetWidth;
          canvasElement.height = targetHeight;
          await new Promise(resolve => {
            videoElement.onloadedmetadata = () => resolve();
          });
          return true;
        } catch (error) {
          console.error(`Error accessing ${facingMode} camera:`, error);
          let errorMessage = `切換到${facingMode === "environment" ? "後置" : "前置"}攝影機失敗: ${error.message}`;
          if (error.name === "NotAllowedError") {
            errorMessage = "Webcam 啟動失敗: 請允許攝影機權限";
          } else if (error.name === "NotFoundError") {
            errorMessage = `無可用${facingMode === "environment" ? "後置" : "前置"}攝影機`;
          } else if (error.name === "NotReadableError") {
            errorMessage = "Webcam 啟動失敗: 攝影機被其他應用程式佔用";
          }
          updateStatus(errorMessage, true);
          return false;
        }
      }

      async function setupWebcam() {
        if (projectType === "audio") {
          updateStatus("音訊專案無需使用 Webcam", true);
          return;
        }
        try {
          if (window.location.protocol !== "https:" && window.location.hostname !== "localhost") {
            updateStatus("Webcam 功能需在 HTTPS 或 localhost 環境運行", true);
            return;
          }
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            updateStatus("此瀏覽器不支援攝影機，請檢查瀏覽器或設備設置", true);
            return;
          }
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          console.log("Available video devices:", videoDevices);
          if (videoDevices.length === 0) {
            updateStatus("未找到可用攝影機，請檢查設備", true);
            return;
          }
          document.getElementById("webcamBtn").disabled = true;
          document.getElementById("webcamSpinner").style.display = "block";
          const webcamContainer = document.getElementById("webcam-container");
          webcamContainer.innerHTML = "";
          webcamContainer.appendChild(switchCameraBtn);
          if (projectType === "image") {
            videoElement = document.createElement("video");
            videoElement.width = 192;
            videoElement.height = 192;
            videoElement.autoplay = true;
            videoElement.playsinline = true;
            videoElement.style.display = "none";
            canvasElement = document.createElement("canvas");
            canvasElement.width = 192;
            canvasElement.height = 192;
            const success = await startCamera(currentFacingMode);
            if (!success) {
              document.getElementById("webcamBtn").disabled = false;
              document.getElementById("webcamSpinner").style.display = "none";
              return;
            }
            webcamContainer.appendChild(videoElement);
            webcamContainer.appendChild(canvasElement);
            labelContainer = document.getElementById("predictions");
            labelContainer.innerHTML = "";
            for (let i = 0; i < maxPredictions; i++) {
              const item = document.createElement("div");
              item.className = "prediction-item";
              item.innerHTML = `
                <span class="prediction-label"></span>
                <span class="prediction-value"></span>
                <progress class="prediction-bar" value="0" max="100"></progress>
              `;
              labelContainer.appendChild(item);
            }
          } else if (projectType === "pose") {
            canvasElement = document.createElement("canvas");
            canvasElement.id = "canvas";
            canvasElement.width = 192;
            canvasElement.height = 192;
            ctx = canvasElement.getContext("2d");
            webcam = new tmPose.Webcam(192, 192, currentFacingMode === "user");
            await webcam.setup();
            await webcam.play();
            webcamContainer.appendChild(canvasElement);
            labelContainer = document.getElementById("predictions");
            labelContainer.innerHTML = "";
            for (let i = 0; i < maxPredictions; i++) {
              const item = document.createElement("div");
              item.className = "prediction-item";
              item.innerHTML = `
                <span class="prediction-label"></span>
                <span class="prediction-value"></span>
                <progress class="prediction-bar" value="0" max="100"></progress>
              `;
              labelContainer.appendChild(item);
            }
          }
          updateStatus("Webcam 已成功啟動", false);
          switchCameraBtn.disabled = false;
          switchCameraBtn.innerText = currentFacingMode === "environment" ? "Switch to Front Camera" : "Switch to Rear Camera";
          if (model && !isPredicting) {
            window.requestAnimationFrame(loop);
            isPredicting = true;
          }
        } catch (error) {
          console.error('Error accessing webcam:', error);
          let errorMessage = "Webcam 啟動失敗: " + error.message;
          if (error.name === "NotAllowedError") {
            errorMessage = "Webcam 啟動失敗: 請允許攝影機權限";
          } else if (error.name === "NotFoundError") {
            errorMessage = "Webcam 啟動失敗: 未找到可用攝影機";
          } else if (error.name === "NotReadableError") {
            errorMessage = "Webcam 啟動失敗: 攝影機被其他應用程式佔用";
          }
          updateStatus(errorMessage, true);
        } finally {
          document.getElementById("webcamBtn").disabled = false;
          document.getElementById("webcamSpinner").style.display = "none";
        }
      }

      async function switchCamera() {
        if (projectType === "audio") return;
        try {
          switchCameraBtn.disabled = true;
          document.getElementById("webcamSpinner").style.display = "block";
          currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          console.log("Available video devices for switch:", videoDevices);
          if (videoDevices.length < 2) {
            updateStatus(`無可用${currentFacingMode === "environment" ? "後置" : "前置"}攝影機`, true);
            currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
            switchCameraBtn.disabled = false;
            document.getElementById("webcamSpinner").style.display = "none";
            return;
          }
          if (projectType === "image") {
            const success = await startCamera(currentFacingMode);
            if (success) {
              switchCameraBtn.innerText = currentFacingMode === "environment" ? "Switch to Front Camera" : "Switch to Rear Camera";
              updateStatus(`已切換到${currentFacingMode === "environment" ? "後置" : "前置"}攝影機`, false);
            } else {
              currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
              switchCameraBtn.innerText = currentFacingMode === "environment" ? "Switch to Front Camera" : "Switch to Rear Camera";
            }
          } else if (projectType === "pose") {
            await webcam.stop();
            webcam = new tmPose.Webcam(192, 192, currentFacingMode === "user");
            await webcam.setup();
            await webcam.play();
            switchCameraBtn.innerText = currentFacingMode === "environment" ? "Switch to Front Camera" : "Switch to Rear Camera";
            updateStatus(`已切換到${currentFacingMode === "environment" ? "後置" : "前置"}攝影機`, false);
          }
        } catch (error) {
          console.error('Error switching camera:', error);
          updateStatus("切換攝影機失敗: " + error.message, true);
          currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
          switchCameraBtn.innerText = currentFacingMode === "environment" ? "Switch to Front Camera" : "Switch to Rear Camera";
        } finally {
          switchCameraBtn.disabled = false;
          document.getElementById("webcamSpinner").style.display = "none";
        }
      }

      async function loop() {
        if (!isPredicting) return;
        if (projectType === "image" && videoElement && model && canvasElement) {
          const ctx = canvasElement.getContext("2d");
          ctx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
          await predict();
        } else if (projectType === "pose" && webcam && model) {
          webcam.update();
          await predict();
        }
        window.requestAnimationFrame(loop);
      }

      async function predict() {
        if (projectType === "image") {
          const prediction = await model.predict(canvasElement);
          let maxProb = 0;
          let maxIndex = 0;
          let highestClass = "";
          for (let i = 0; i < maxPredictions; i++) {
            const prob = (prediction[i].probability * 100).toFixed(2);
            const item = labelContainer.childNodes[i];
            item.querySelector(".prediction-label").innerText = prediction[i].className;
            item.querySelector(".prediction-value").innerText = `${prob}%`;
            item.querySelector(".prediction-bar").value = prob;
            item.classList.toggle("highest", prob > maxProb);
            if (prob > maxProb) {
              maxProb = prob;
              maxIndex = i;
              highestClass = prediction[i].className;
            }
            if (prediction[i].probability >= 0.995 && prediction[i].className !== lastSentClass) {
              await sendData(prediction[i].className);
              lastSentClass = prediction[i].className;
            }
          }
          if (isGameMode && maxProb >= 99 && highestClass === currentTarget) {
            matchCount++;
            document.getElementById("matchCount").innerText = matchCount;
            if (matchCount >= matchGoal) {
              endGame();
            } else {
              pickNewTarget();
              updateStatus("匹配成功！下一目標: " + currentTarget, false);
            }
          }
        } else if (projectType === "pose") {
          const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
          const prediction = await model.predict(posenetOutput);
          let maxProb = 0;
          let maxIndex = 0;
          let highestClass = "";
          for (let i = 0; i < maxPredictions; i++) {
            const prob = (prediction[i].probability * 100).toFixed(2);
            const item = labelContainer.childNodes[i];
            item.querySelector(".prediction-label").innerText = prediction[i].className;
            item.querySelector(".prediction-value").innerText = `${prob}%`;
            item.querySelector(".prediction-bar").value = prob;
            item.classList.toggle("highest", prob > maxProb);
            if (prob > maxProb) {
              maxProb = prob;
              maxIndex = i;
              highestClass = prediction[i].className;
            }
            if (prediction[i].probability >= 0.995 && prediction[i].className !== lastSentClass) {
              await sendData(prediction[i].className);
              lastSentClass = prediction[i].className;
            }
          }
          if (webcam.canvas) {
            ctx.drawImage(webcam.canvas, 0, 0);
            if (pose) {
              const minPartConfidence = 0.5;
              tmPose.drawKeypoints(pose.keypoints, minPartConfidence, ctx);
              tmPose.drawSkeleton(pose.keypoints, minPartConfidence, ctx);
            }
          }
          if (isGameMode && maxProb >= 99 && highestClass === currentTarget) {
            matchCount++;
            document.getElementById("matchCount").innerText = matchCount;
            if (matchCount >= matchGoal) {
              endGame();
            } else {
              pickNewTarget();
              updateStatus("匹配成功！下一目標: " + currentTarget, false);
            }
          }
        }
      }

      function startGame() {
        if (projectType === "audio") {
          updateStatus("遊戲僅支援圖像和姿勢專案", true);
          return;
        }
        if (classNames.length === 0) {
          updateStatus("請先載入模型", true);
          return;
        }
        if (!isPredicting) {
          updateStatus("請先開啟 Webcam", true);
          return;
        }
        matchGoal = parseInt(document.getElementById("matchGoal").value) || 10;
        if (matchGoal < 5 || matchGoal > 20) {
          updateStatus("題目數必須在5-20之間", true);
          return;
        }
        document.getElementById("currentMatchGoal").innerText = matchGoal;
        isGameMode = true;
        matchCount = 0;
        lastTarget = "";
        gameStartTime = Date.now();
        document.getElementById("matchCount").innerText = matchCount;
        document.getElementById("timer").innerText = 0;
        document.getElementById("gameResult").style.display = "none";
        document.getElementById("startGameBtn").disabled = true;
        document.getElementById("resetGameBtn").disabled = false;
        pickNewTarget();
        updateStatus("遊戲開始！匹配目標: " + currentTarget, false);
        startTimer();
      }

      function resetGame() {
        isGameMode = false;
        matchCount = 0;
        currentTarget = "";
        lastTarget = "";
        document.getElementById("targetClass").innerText = "";
        document.getElementById("matchCount").innerText = 0;
        document.getElementById("timer").innerText = 0;
        document.getElementById("gameResult").style.display = "none";
        document.getElementById("startGameBtn").disabled = model ? false : true;
        document.getElementById("resetGameBtn").disabled = true;
        stopTimer();
        updateStatus("遊戲已重置", false);
      }

      function pickNewTarget() {
        let randomIndex = Math.floor(Math.random() * classNames.length);
        while (classNames[randomIndex] === lastTarget && classNames.length > 1) {
          randomIndex = Math.floor(Math.random() * classNames.length);
        }
        currentTarget = classNames[randomIndex];
        lastTarget = currentTarget;
        document.getElementById("targetClass").innerText = currentTarget;
      }

      function startTimer() {
        gameTimerInterval = setInterval(() => {
          if (gameStartTime) {
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            document.getElementById("timer").innerText = elapsed;
          }
        }, 1000);
      }

      function stopTimer() {
        clearInterval(gameTimerInterval);
        gameTimerInterval = null;
      }

      function endGame() {
        isGameMode = false;
        const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
        document.getElementById("gameResult").innerText = `遊戲結束！總時間: ${elapsed} 秒`;
        document.getElementById("gameResult").style.display = "block";
        document.getElementById("targetClass").innerText = "";
        stopTimer();
        updateStatus("遊戲結束！總時間: " + elapsed + " 秒", false);
        document.getElementById("startGameBtn").disabled = false;
      }
    </script>
</body>
</html>